%==============================================================================
\documentclass[11pt,oneside,onecolumn,letterpaper]{article}
\usepackage{times}
\usepackage[paperwidth=8.5in, paperheight=11in,
top=2.5cm, bottom=2.6cm, left=2.58cm, right=2.53cm]{geometry}
%\setlength{\textheight} {9.00in}
%\setlength{\textwidth}  {6.40in}
%\setlength{\topmargin}  {-0.50in}
%%\setlength{\headheight} {0.00in}
%%\setlength{\headsep}     {0.40in}
%\setlength{\oddsidemargin}{-0.010in}
%\setlength{\evensidemargin}{-0.00in}
%==============================================================================
%\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{color}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[hyphens]{url}
\usepackage{pifont}
\usepackage{color}
\usepackage{colortbl}
\usepackage[lined, boxed, linesnumbered]{algorithm2e}
\usepackage[square, comma, sort&compress, numbers]{natbib}

\newcounter{alg}
\newenvironment{enum-ref}{
\begin{list}%
{[\arabic{alg}]} {\usecounter{alg}
  \setlength{\leftmargin} {0.25in}
  \setlength{\labelwidth} {0.30in}
  \setlength{\rightmargin}{0.00in}
  \setlength{\topsep}     {0.00in}}
}{\end{list}}

\newenvironment{enum-number}{
\begin{list}%
{\arabic{alg})} {\usecounter{alg}
  \setlength{\leftmargin} {0.25in}
  \setlength{\labelwidth} {0.30in}
  \setlength{\rightmargin}{0.00in}
  \setlength{\topsep}     {0.00in}}
}{\end{list}}

\newenvironment{enum-nonum}{
\begin{list}%
{$\bullet$} {
  \setlength{\leftmargin} {0.25in}
  \setlength{\labelwidth} {0.30in}
  \setlength{\rightmargin}{0.00in}
  \setlength{\topsep}     {0.00in}}
}{\end{list}}

\let\chapter\section

%==============================================================================
\pagestyle{plain}
%==============================================================================

\title{Secure UAV Communications System Design}
\author{Team Cacti, University at Buffalo}
\date{}



\begin{document}
%%
%=============================================================================
\normalsize


\maketitle
%\date{}

\renewcommand{\thepage}{System Design, Team Cacti, University at Buffalo--\arabic{page}}
\setcounter{page}{1} \normalsize
%
%\renewcommand{\baselinestretch}{1.2}
%\normalsize
%\vspace{0.1in}
%\centerline{\textbf{\Large }}
%\renewcommand{\baselinestretch}{1.0}
%\normalsize

\newcommand{\flagRollback}{\textsf{Rollback}\xspace}

\section{Introduction}

This is the design document of team Cacti for MITRE eCTF 2021.

\subsection{Entities}

A SED (SCEWL-Enabled Devices) is a device with a SCEWL Bus installed. 
A SED is implemented in 2 parts: 1) CPU, which runs on ARM Cortex-A + Linux (Cannot be changed); 2) 
Microcontroller, which runs on ARM Cortex-M + Firmware. 
	
SED devices include: 
1) C2 SED (fixed location, unknown \verb|SCEWL_ID|); 
2) drop-zone SED ((fixed location, unknown \verb|SCEWL_ID|)); 
3) drone SED (fly to places, unknown \verb|SCEWL_ID|)

The following summarizes the entities in the system.

\begin{itemize}
	\item A SED CPU works at the application layer. UAV ID is used to identify drone SED CPU at the application layer. UAV ID is a secret like any other data fields at the application layer.
	
	\item A SED controller is identified by a \verb|SCEWL_ID|, which is 16 bits in length. Note that a UAV ID is different from a \verb|SCEWL_ID|. The UAV ID is a secret that controlled by the CPU.
	
	\item SSS (SCEWL Security Server) manages SEDs through registration
and deregistration. SSS does not communicate with any SED besides registration
and deregistration. SSS has a SCEWL ID of 1.
	
	\item FAA Transceiver is a device that allows the FAA to communicate with any SED, bypassing the secure SCEWL protocol that we design. FAA Transceiver has a SCEWL ID of 2.
\end{itemize}

\subsection{Communication Channels}

Following the OSI network model, we divide the network into 3 layers. 
Layer 1: the physical layer, which include radio and wired. There are implemented by UNIX socks, radio.py, etc.
Layer 2: a combination of the data link layer, network layer and transport layer, which is implemented at the controller. 
Our job is to provide security mechanisms at layer 2 before forwarding the message to layer 1 or layer 3.
Layer 3: the application layer, which is out of our control and implemented at the CPU. The application layer has its own checksum.

This following summarizes the communication channels in the system.

\begin{itemize}
	\item A SED CPU can send a targeted message to another SED CPU via radio. This message will go through the SED controller. This message must be encrypted and authenticated at controller, so only the targeted SED controller can decrypt the message and any tampering to the message by an attacker can be detected. 
	
	\item A SED CPU can send out a broadcast message to all other registered SED CPUs. This message will go through the SED controller. This message must be encrypted and authenticated as well. Only registered SED controller should be able to decrypt this message, and any tampering to the message by an attacker should be detected. 
	
	\item In registration and deregistration, a SED only talks with SSS in a wired and secured channel. No further protection is needed for this channel.
	
	\item SED CPU uses the FAA channel to talk with us, sending status notifications to us.
\end{itemize}

\subsection{Message Format}

The physical layer / data link layer frame has a header described in Section 4.6 of Rules.
The header has 8 bytes.
It has 2 bytes of magic number, 2 bytes of destination SCEWL ID, 2 bytes of source SCEWL ID, 2 bytes of body length in bytes.
The header cannot be encrypted, since it is used for routing.
But, it should be authenticated to prevent tampering.

\section{Attack Models}

The attackers can carry out the following attacks:

\begin{itemize}
	\item Intercept a targeted message and try to decrypt that, getting the Package Recovery flag.

	\item Intercept a broadcast message and try to decrypt that, getting the UAV ID Recovery flag.	
	
	\item Send a targeted message to any drone SED to make it drop a package, getting the Drop Package flag.		
	
	\item Replay the redirect message from FAA to make a drove SED fly above its altitude ceiling.
	
	\item Extract secret from a crashed drone SED firmware.  
	
	\item Spoof an FAA transceiver. But, the controller must pass all FAA messages without authentication.
\end{itemize}

\section{Our Design}

Each SED controller $k$ has a public key pair ($pk_k, sk_k$).
Each SED stores all other SEDs' $pk_k$.
ENC and DEC stands for symmetric encryption and decryption with AES.
AENC and ADEC stands for asymmetric encryption and decryption with RSA.

\subsection{Targeted Transmission}
Whenever the SED $a$ sends a targeted message to SED $b$, it first generates an AES key $k_a$ and IV $iv_a$. 
Then, it uses AES-GCM to encrypt and authenticate the SCEWL header ($\mathcal{H}$) and body ($\mathcal{B}$), which outputs the ciphertext ($\mathcal{C}$) and tag ($\mathcal{T}$), e.g. $\mathcal{C}, \mathcal{T}$=ENC$_{k_a, iv_a}(\mathcal{H} || \mathcal{B})$.
Then, it encrypts $k_a$ with $pk_b$, e.g. AENC$_{pk_b}(k_a)$.
Then, it sends out $\mathcal{M}=\mathcal{H} || $AENC$_{pk_b}(k_a)||iv_a||\mathcal{T}||\mathcal{C}$.
A caveat here is to calculate body length before the AES operation.

Whenever SED $b$ receives a targeted message $\mathcal{M}$, it first checks the $\mathcal{H}$ to see if the message is intended for it. If not, discard.
Then, it uses its private key $sk_b$ to decryt the received ciphertext AES key $k_a$, e.g. $k_a=$ADEC$_{sk_b}($AENC$_{pk_b}(k_a))$.
Then, it uses $k_a, iv_a$ to decrypt and authenticate the message, e.g. $\mathcal{C'}, \mathcal{T'}$=DEC$_{k_a, iv_a}(\mathcal{C})$.
It compares $\mathcal{T'}$ and $\mathcal{T}$.
If they do not match, discard.
Otherwise, $\mathcal{C'}=\mathcal{H}||\mathcal{B}$.

\subsection{Broadcast}
Whenever the SED $a$ sends a broadcast message, it first generates an AES key $k_a$ and IV $iv_a$. 
Then, it uses AES-GCM to encrypt and authenticate the SCEWL header ($\mathcal{H}$) and body ($\mathcal{B}$), which outputs the ciphertext ($\mathcal{C}$) and tag ($\mathcal{T}$), e.g. $\mathcal{C}, \mathcal{T}$=ENC$_{k_a, iv_a}(\mathcal{H} || \mathcal{B})$.
Then, it encrypts $k_a$ with $pk_b$, e.g. AENC$_{pk_b}(k_a)$.
Then, it sends out $\mathcal{M}=\mathcal{H} || $AENC$_{pk_b}(k_a)||iv_a||\mathcal{T}||\mathcal{C}$.
A caveat here is to calculate body length before the AES operation.

Whenever SED $b$ receives a targeted message $\mathcal{M}$, it first checks the $\mathcal{H}$ to see if the message is intended for it. If not, discard.
Then, it uses its private key $sk_b$ to decryt the received ciphertext AES key $k_a$, e.g. $k_a=$ADEC$_{sk_b}($AENC$_{pk_b}(k_a))$.
Then, it uses $k_a, iv_a$ to decrypt and authenticate the message, e.g. $\mathcal{C'}, \mathcal{T'}$=DEC$_{k_a, iv_a}(\mathcal{C})$.
It compares $\mathcal{T'}$ and $\mathcal{T}$.
If they do not match, discard.
Otherwise, $\mathcal{C'}=\mathcal{H}||\mathcal{B}$.

When \verb|SSS| runs for the first time, generates AES keys for each SED pair beforehand. 
When each SED registers,

The transmissions between SEDs must be encrypted and authenticated.
Only the SEDs that have the correct key can decrypt the message.
All messages in between will be authenticated to check the integrity.

\subsection{Message Crypto}
To encrypt the message, asymmetric encryption (AES) is used.
Which we chose will be AES with CBC, CTR, or GCM mode.
The key is called SED\_aes\_key which is unique for each SED.
Every SED stores a list of keys for the activated SEDs which will be used to encrypt or decrypt the messages.

\subsubsection{Possible Asymmetric Crypto}
If the performance is good enough, we will additionally implement asymmetric encryption, such as RSA, to encrypt the AES key.
In this design, each SED has the AES key plus a pair of a public key (SED\_pub\_key) and a private key(SED\_pri\_key).
Also, each SED stores a list of public keys of the activated SEDs.

To send a message, SED\_a will use the AES key to encrypt the message body first (ciphertext), then use the SED\_b's public key to encrypt the AES key (en\_key).
Then send the en\_key and ciphertext to SED\_b'.

To read the message, SED\_b uses its private key to decrypt the en\_key to get the AES key, then encrypt the ciphertext. 

\subsection{Message Authentication}
To do authentication, there are two alternations to chosse which we prefer to use AES-GCM.
\begin{itemize}
  \item[1] hmac with size 512 (may change).
  The key for hmac is called SED\_hmac\_key.
  \item[2] AES with GCM mode.
\end{itemize}

\subsection{Message Continous}
Each transition will be tagged with a timestamp (or sequence number inside the message body) to prevent the replay attack.

\subsection{Key Generation and Storage}
SSS maintains all keys for all activated SEDs and its own keys.
This key list will be shared with each newly registered SED.

Like we discussed in previous sections, each provisioned SED also has its own SED\_key dictionary (SED\_hma\_key, SED\_aes\_key additionally with SED\_pub\_key and SED\_pri\_key) which will be used to encrypt and authenticate the message in transitions.

When register a SED, the SSS is responsible to generate the SED\_keys and update it.
The newly inserted SED will broadcast the key to other SEDs to update the key of the associated ID.

When deregistering a SED, the SED will broadcast to other SEDs first to delete the SED\_keys, then the SSS will destroy the SED\_keys in its own storage.

In detail:
\begin{itemize}
  \item When we add the SEDs with \textbf{add\_sed}  
      command we generate secrets for each SED. 
      \item We will use symmetric key encryption for SED to SED communication (AES).
      \item We change the  \textbf{dockerfiles/2b\_create\_sed\_secrets.Dockerfile} file to generate the keys for each pair of SEDs to communicate with each other.
      \item Store the keys in the containers \textbf{secret} directory.
      \item As every SED will have all the key pairs in the network, the authenticity of each message can be verified.
      % \item Along with the AES Keys for communication we may also generate one key for each SED to do \textbf{hmac} on the header and message body. 
      % Here the hmac preserves the integrity of the message header and message body.
\end{itemize}

\subsection{Secure the Broadcast}
Whenever the register or deregister happens, this SED will broadcast its status to update the SED\_keys stored in other SEDs.
Implementing the TESLA broadcast authentication protocol is in our work pipeline, too.

\subsubsection{Message format}
The original message format is eight bytes of metadata followed by the frame body.
We will change the frame body into an encrypted body with AES plus hmac of the header and encrypted body.

  \begin{itemize}
  \item In case of SED to SED communication: \textbf{header + hmac(header + AES (body)) + AES(body)} or \textbf{header + aes-gcm(header + body)}
  \item In case of incoming message from FAA transceiver we receive the message as given format: \textbf{header + body}
  \end{itemize}
  \begin{itemize}
  \item We will add a sequence number in from of the message body. We check the sequence number from the message after decryption to prevent reply attack.
  \end{itemize}

\subsection{Build Process}

  \begin{itemize}
    \item \textbf{dockerfiles/1a\_create\_sss.Dockerfile}: Generate or destory keys for SEDs registration and deregistration.
    \item \textbf{dockerfiles/2b\_create\_sed\_secrets.Dockerfile}: Store the key list for actived SEDs.
    \item \textbf{dockerfiles/2c\_build\_controller.Dockerfile}: Generate any other secrets.
    \item ...
  \end{itemize}

\section{Implementation}
\subsection{Critical Functions and Files}
\begin{itemize}
  \item sss.py: check the provisoned SEDs.
  \item controller.c: add message encryption, decryption, and authentication, update keys.
  \item others are still in progress.
\end{itemize}


% \section{Flag Protection}

% \subsection{\textsf{D}}


\end{document}
%==============================================================================
