%==============================================================================
\documentclass[11pt,oneside,onecolumn,letterpaper]{article}
\usepackage{times}
\usepackage[paperwidth=8.5in, paperheight=11in,
top=2.5cm, bottom=2.6cm, left=2.58cm, right=2.53cm]{geometry}
%\setlength{\textheight} {9.00in}
%\setlength{\textwidth}  {6.40in}
%\setlength{\topmargin}  {-0.50in}
%%\setlength{\headheight} {0.00in}
%%\setlength{\headsep}     {0.40in}
%\setlength{\oddsidemargin}{-0.010in}
%\setlength{\evensidemargin}{-0.00in}
%==============================================================================
%\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{color}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[hyphens]{url}
\usepackage{pifont}
\usepackage{color}
\usepackage{colortbl}
\usepackage[lined, boxed, linesnumbered]{algorithm2e}
\usepackage[square, comma, sort&compress, numbers]{natbib}

\newcounter{alg}
\newenvironment{enum-ref}{
\begin{list}%
{[\arabic{alg}]} {\usecounter{alg}
  \setlength{\leftmargin} {0.25in}
  \setlength{\labelwidth} {0.30in}
  \setlength{\rightmargin}{0.00in}
  \setlength{\topsep}     {0.00in}}
}{\end{list}}

\newenvironment{enum-number}{
\begin{list}%
{\arabic{alg})} {\usecounter{alg}
  \setlength{\leftmargin} {0.25in}
  \setlength{\labelwidth} {0.30in}
  \setlength{\rightmargin}{0.00in}
  \setlength{\topsep}     {0.00in}}
}{\end{list}}

\newenvironment{enum-nonum}{
\begin{list}%
{$\bullet$} {
  \setlength{\leftmargin} {0.25in}
  \setlength{\labelwidth} {0.30in}
  \setlength{\rightmargin}{0.00in}
  \setlength{\topsep}     {0.00in}}
}{\end{list}}

\let\chapter\section

%==============================================================================
\pagestyle{plain}
%==============================================================================

\title{Secure UAV Communications System Design}
\author{Team Cacti, University at Buffalo}
\date{}



\begin{document}
%%
%=============================================================================
\normalsize


\maketitle
%\date{}

\renewcommand{\thepage}{System Design, Team Cacti, University at Buffalo--\arabic{page}}
\setcounter{page}{1} \normalsize
%
%\renewcommand{\baselinestretch}{1.2}
%\normalsize
%\vspace{0.1in}
%\centerline{\textbf{\Large }}
%\renewcommand{\baselinestretch}{1.0}
%\normalsize

\newcommand{\flagRollback}{\textsf{Rollback}\xspace}

\section{Introduction}

This is the design document of team Cacti for MITRE eCTF 2021.

\subsection{Entities}

A SED (SCEWL-Enabled Devices) is a device with a SCEWL Bus installed. 
A SED is implemented in 2 parts: 1) CPU, which runs on ARM Cortex-A + Linux (Cannot be changed); 2) 
Microcontroller, which runs on ARM Cortex-M + Firmware. 
	
SED devices include: 
1) C2 SED (fixed location, unknown \verb|SCEWL_ID|); 
2) drop-zone SED ((fixed location, unknown \verb|SCEWL_ID|)); 
3) drone SED (fly to places, unknown \verb|SCEWL_ID|)

The following summarizes the entities in the system.

\begin{itemize}
	\item A SED CPU works at the application layer. UAV ID is used to identify drone SED CPU at the application layer. UAV ID is a secret like any other data fields at the application layer.
	
	\item A SED controller is identified by a \verb|SCEWL_ID|, which is 16 bits in length. Note that a UAV ID is different from a \verb|SCEWL_ID|. The UAV ID is a secret that controlled by the CPU.
	
	\item SSS (SCEWL Security Server) manages SEDs through registration
and deregistration. SSS does not communicate with any SED besides registration
and deregistration. SSS has a SCEWL ID of 1.
	
	\item FAA Transceiver is a device that allows the FAA to communicate with any SED, bypassing the secure SCEWL protocol that we design. FAA Transceiver has a SCEWL ID of 2.
\end{itemize}

\subsection{Communication Channels}

Following the OSI network model, we divide the network into 3 layers. 
Layer 1: the physical layer, which include radio and wired. There are implemented by UNIX socks, radio.py, etc.
Layer 2: a combination of the data link layer, network layer and transport layer, which is implemented at the controller. 
Our job is to provide security mechanisms at layer 2 before forwarding the message to layer 1 or layer 3.
Layer 3: the application layer, which is out of our control and implemented at the CPU. The application layer has its own checksum.

This following summarizes the communication channels in the system.

\begin{itemize}
	\item A SED CPU can send a targeted message to another SED CPU via radio. This message will go through the SED controller. This message must be encrypted and authenticated at controller, so only the targeted SED controller can decrypt the message and any tampering to the message by an attacker can be detected. 
	
	\item A SED CPU can send out a broadcast message to all other registered SED CPUs. This message will go through the SED controller. This message must be encrypted and authenticated as well. Only registered SED controller should be able to decrypt this message, and any tampering to the message by an attacker should be detected. 
	
	\item In registration and deregistration, a SED only talks with SSS in a wired and secured channel. No further protection is needed for this channel.
	
	\item SED CPU uses the FAA channel to talk with us, sending status notifications to us.
\end{itemize}

\subsection{Message Format}

The physical layer / data link layer frame has a header described in Section 4.6 of Rules.
The header has 8 bytes.
It has 2 bytes of magic number, 2 bytes of destination SCEWL ID, 2 bytes of source SCEWL ID, 2 bytes of body length in bytes.
The header cannot be encrypted, since it is used for routing.
But, it should be authenticated to prevent tampering.

\section{Attack Models}

The attackers can carry out the following attacks:

\begin{itemize}
	\item Intercept a targeted message and try to decrypt that, getting the Package Recovery flag.

	\item Intercept a broadcast message and try to decrypt that, getting the UAV ID Recovery flag.	
	
	\item Send a targeted message to any drone SED to make it drop a package, getting the Drop Package flag.		
	
	\item Replay the redirect message from FAA to make a drove SED fly above its altitude ceiling.
	
	\item Extract secret from a crashed drone SED firmware.  
	
	\item Spoof an FAA transceiver. But, the controller must pass all FAA messages without authentication.
	
	\item Launch their own spoofed SEDs onto the network, which may run malicious images on CPU and controller.
\end{itemize}

\section{Our Design}
% SSS stores all public keys ($pk_k$) of all provisioned SEDs. 
Each SED controller $k$ has a public key pair ($pk_k, sk_k$).
Each SED stores all other SEDs' $pk_k$.
ENC and DEC stands for symmetric encryption and decryption with AES.
AENC and ADEC stands for asymmetric encryption and decryption with RSA.

\subsection{Targeted Transmission}
Whenever the SED $a$ sends a targeted message to SED $b$, it first generates an AES key $k_a$ and IV $iv_a$. 
Then, it uses AES-GCM to encrypt and authenticate the SCEWL header ($\mathcal{H}$) and body ($\mathcal{B}$), which outputs the ciphertext ($\mathcal{C}$) and tag ($\mathcal{T}$), e.g. $\mathcal{C}, \mathcal{T}$=ENC$_{k_a, iv_a}(\mathcal{H} || \mathcal{B})$.
Then, it encrypts $k_a$ with $pk_b$, e.g. AENC$_{pk_b}(k_a)$.
Then, it sends out $\mathcal{M}=\mathcal{H} || $AENC$_{pk_b}(k_a)||iv_a||\mathcal{T}||\mathcal{C}$.
A caveat here is to calculate body length before the AES operation.

Whenever SED $b$ receives a targeted message $\mathcal{M}$, it first checks the $\mathcal{H}$ to see if the message is intended for it. If not, discard.
Then, it uses its private key $sk_b$ to decryt the received ciphertext AES key $k_a$, e.g. $k_a=$ADEC$_{sk_b}($AENC$_{pk_b}(k_a))$.
Then, it uses $k_a, iv_a$ to decrypt and authenticate the message, e.g. $\mathcal{C'}, \mathcal{T'}$=DEC$_{k_a, iv_a}(\mathcal{C})$.
It compares $\mathcal{T'}$ and $\mathcal{T}$.
If they do not match, discard.
Otherwise, $\mathcal{C'}=\mathcal{H}||\mathcal{B}$.

\subsection{Key Generation and Storage}

Below are the details Key generation for asymmetric encryption:
\begin{itemize}
  \item[Step1. ] When adding SED$_k$ to the deployment, SSS generates a pair of keys ($pk_k$, $sk_s$) for it.
  Stores as \verb|SCEWL_ID|.$pub$, \verb|SCEWL_ID|.$pri$
  \item[Step2. ] When building controller for SED$_k$, the key pair ($pk_k$, $sk_s$) will be copied to this controller container.
  SSS only remain the $pk_k$. 
  \item[Step3. ] At registration stage, the SED$_k$ uses its own private key ($sk_k$) to send the registration message to SSS.
  If the \verb|SCEWL_ID| is in our provisoned SED list, SSS will use the associated public key ($pk_k$) to decrypt this message and finish the registration for it.
  After registration is done, all public keys for other SEDs will be copied to the registered one.
  \item[Step4. ] When removing SED$_k$, SSS will delete $pk_k$ (SSS already deleted $sk_k$ at step 2).
\end{itemize}

In detail:
\begin{itemize}
      \item We develop \textbf{create\_secrets.py}(with SCEWL\_ID as a parameter) script to generate key pair ($pk_1$ and $sk_1$) for each provisioned SED and run the script from  \textbf{dockerfiles/2b\_create\_sed\_secrets.Dockerfile} file.

      \item All these secrets will be kept in the \textbf{secret} directory of SSS container.
      \item At the time of building the controller of SED's \textbf{dockerfiles/2c\_build\_controller.Dockerfile}  gets invoked, we change this file to copy the secrets from the SSS container to the controller container.
      \item We modify the \textbf{sss.py} to verify the provioned SEDs and send out the public keys of other SED when registration.
     % \item As every SED will have all the key pairs in the network, the authenticity of each message can be verified.
      % \item Along with the AES Keys for communication we may also generate one key for each SED to do \textbf{hmac} on the header and message body. 
      % Here the hmac preserves the integrity of the message header and message body.
\end{itemize}

% \subsection{Secure the Broadcast}
% Whenever the register or deregister happens, this SED will broadcast its status to update the SED\_keys stored in other SEDs.
% Implementing the TESLA broadcast authentication protocol is in our work pipeline, too.

% \subsubsection{Message format}
% The original message format is eight bytes of metadata followed by the frame body.
% We will change the frame body into an encrypted body with AES plus hmac of the header and encrypted body.

%   \begin{itemize}
%   \item In case of SED to SED communication: \textbf{header + hmac(header + AES (body)) + AES(body)} or \textbf{header + aes-gcm(header + body)}
%   \item In case of incoming message from FAA transceiver we receive the message as given format: \textbf{header + body}
%   \end{itemize}

  \subsection{Prevent Replay Attack}
  We will add a sequence number in front of the message body. We check the sequence number for each message to prevent a reply attack.
  In details:
  \begin{itemize}
  \item Suppose there are 5 ($a, b, c, d, e$) SED's in the system.
  \item Each SED maintains a table containing other SED's sequence numbers with default value zero.
  \item  Example: At the beginning for SED $b$:

    \begin{center}
  \begin{tabular}{ |c|c| } 
   \hline
  \textbf{SED ID} & \textbf{Sequence Number} \\
 	\hline \hline
 	a & 0 \\ 
	c & 0  \\ 
 	d & 0 \\ 
 	e & 0 \\ 
	 \hline
\end{tabular}
\end{center}
  \item Suppose SED $a$ communicates with the SED $b$, $a$ sends its corresponding sequence of b($0$) in the message. After decrypting the message SED $b$ checks with the SED $a$ value if it's less or equal to the received number then it's a legit message. 
  \item Then both SED $a$ and $b$ increments their corresponding sequence number by one.
  \item After communication table for SED $b$:
    \begin{center}
  \begin{tabular}{ |c|c| } 
   \hline
  \textbf{SED ID} & \textbf{Sequence Number} \\
 	\hline \hline
 	a & 1 \\ 
	c & 0  \\ 
 	d & 0 \\ 
 	e & 0 \\ 
	 \hline
\end{tabular}
\end{center}
\item Similarly, suppose SED $b$ twice communicates with SED $c$ and once with SED $e$. Now the table for SED $b$ should be:
   \begin{center}
  \begin{tabular}{ |c|c| } 
   \hline
  \textbf{SED ID} & \textbf{Sequence Number} \\
 	\hline \hline
 	a & 1 \\ 
	c & 2  \\ 
 	d & 0 \\ 
 	e & 1 \\ 
	 \hline
\end{tabular}
\end{center}
    \end{itemize}


\subsection{Build Process}

  \begin{itemize}
    \item \textbf{dockerfiles/1a\_create\_sss.Dockerfile}: Generate or destory keys for SEDs registration and deregistration.
    \item \textbf{dockerfiles/2b\_create\_sed\_secrets.Dockerfile}: Store the key list for actived SEDs.
    \item \textbf{dockerfiles/2c\_build\_controller.Dockerfile}: Generate any other secrets.
    \item ...
  \end{itemize}

\section{Implementation}
\subsection{Critical Functions and Files}
\begin{itemize}
  \item sss.py: check the provisoned SEDs.
  \item controller.c: add message encryption, decryption, and authentication, update keys.
  \item others are still in progress.
\end{itemize}


% \section{Flag Protection}

% \subsection{\textsf{D}}


\end{document}
%==============================================================================
